상수항 무시
O(2N) -> O(N)
O(N² + 2) -> O(N²)

영향력 없는 항 무시
O(N² + N) -> O(N²)
O(N²)이 가장 지배적이기 때문에 그 외에 영향력이 없는 항들은 무시합니다.

O(1) < O(log n) < O(n) < O(n log n) < O(n²)  < O(n³)  < O(2ⁿ) < O(n!) < O(nⁿ)

시간복잡도 :  속도에 해당하는 알고리즘의 수행시간 분석결과

공간복잡도 : 메모리 사용량에 대한 분석결과

※ 일반적으로 중요도는 실행속도가 메모리 사용량보다 중요하다.
※ 알고리즘의 성능을 판단하는데 있어서 중요한 것은 '최악의 경우'이다.

https://cjh5414.github.io/big-o-notation/
https://brenden.tistory.com/2


빅-오표기법 (Big-O Notation)
 빅-오는 시간복잡도 T(n) 에서 가장 영향력이 큰 부분을 따지는 것이다.
 데이터 수의 증가에 따른 연산횟수의 증가형태를 나타내는 표기법이다.

ex)  T( n² + 2n + 1 ) 일 경우 빅-오 표기법으로는  O( n²) 이 된다.

빅-오 표기법의 성능(수행시간, 연산횟수)

O(1) : 상수형 빅-오, 데이터 수에 상관없이 '연산횟수가 고정'인 유형의 알고리즘을 뜻한다.
O(log n) : 로그형 빅-오, '데이터 수의 증가율'에 비하여 '연산횟수의 증가율'이 훨씬 낮은 알고리즘
O(n) : 선형 빅-오, 데이터 수와 연산횟수가 비례하는 알고리즘
O(n*log n) : 선형 로그형 빅-오, 데이터의 수가 2배로 늘 때, 연산횟수는 2배 조금 넘게 증가하는 알고리즘
O(2ⁿ) : 지수형 빅-오, '지수적 증가'는 무서운 연산횟수의 증가를 보이기 때문에 다른 방안을 찾아야한다.